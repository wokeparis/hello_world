小米：
1.static成员函数和普通成员函数的区别
    static没有this指针，不属于某一个对象而是属于类
2.epoll水平模式和触发模式
    下面说的全是触发模式：
    触发模式的触发条件，以读为例子（写差不多）。 在已经添加的条件下，1.ctl的时候如果里面有值 2.数据从无到有 3.数据值变化。
    (EPOLLIN|EPOLLOUT)可以这样一次性指定一个文件描述符。读写都检测。  触发读的时候同时会触发是否可写的检测
    两个epoll监测同一个fd，两个都能收到事件。
    epoll文件描述符也是可读的。
    如果读的时候又来数据了，然后读完了，直接触发再来一次recv直接报错也相当于读完。
    如果读的时候一直来数据。会造成饥饿，所有的其他fd无法操作，然后可以自己维护一个列表，每个fd操作一定次，然后循环操作，直到所有fd都不是active
    触发条件测试。如果收到一个fin，水平模式和触发模式的情况
        都会触发，通过判断read返回值=0。也可以通过触发epollrdhup来判断。
3.构造函数可不可以是虚函数，不可以是虚函数，虚函数需要使用虚函数表，函数没构造的时候没有虚函数表，如果构造函数是虚函数怎么构造函数呢？
4.析构函数如果不是虚函数，作为基类会出现什么问题？
B：A    A* a = new B；这个a析构的时候 只析构基类不析构派生类  
5.字节对齐是和系统位数对应的
6.三次握手如果丢包了怎么办
第一个包如果丢包了，相当于这个过程没有开始，client应该重发
第二个包如果丢了，server一定时间后应该重发
第三个包丢了和第二个包的情况一样
第二个包和第三个包丢失的情况可以被用来泛洪攻击
7.函数重载参数有const不构成重载，const成员函数可以和非const成员函数重载。只有成员函数才有const，非成员函数没有。顶层const也构成重载。
基类和派生类只要有同名函数，没有被virtual修饰，那么基类的成员函数被隐藏。被virtual修饰就得满足虚函数的要求，参数数量要一致
8.reinterpret_cast  目标和源必须有一个是指针或引用。从位上重新解释
static_cast 在从大类型转到小类型时，先截断，在解释。如果位数一致，直接解释（如果两个位数一致但值范围不一致，还是超了，那么会取一个最大值）。

金山：
1.vector清空的方法，清空 vector<int> a  vector<int>().swap(a);   将a与一个新建的vector交换，只是将大小和首尾指针进行交换，原来的数据变成临时值，会被析构掉
另一种用法： vector<int>(a).swap(a);可以将a变成最适合的大小。

商汤：
1.智能指针的实现，找时间可以看一下

百度：
1.一个可执行文件 由代码（text）、静态数据和全局初始化数据(data)、全局未初始化数据区(bss)。
2.内存泄漏如何调查：内存泄漏一般有两种结果，一个是程序down掉，也有可能不会down掉但是内存不足。或者莫名其妙被占用一大块内存，性能降低。
内存泄漏的原因是堆内存申请后没有释放。有的时候也可以指唔见描述符或者socket资源没有回收。

如果down掉，查看core文件，如果没有发现异常的退出点，就应该怀疑是内存泄漏。
如果怀疑内存泄漏，通过free命令查看内存用量是否上升或者螺旋上升。也可以使用top和ps -aux来看

解决办法，尽可能使用只能指针。重载new delete方法添加统计内存分配和释放的模块。经验new delete自己控制好。
使用valgrind的memcheck检查。面试官说大型工程不能用可以试一下。
cppcheck华为。

3.自己的职业规划，离职相关：

4.虚函数表的调用方式。

