//static成员函数和普通成员函数的区别 static没有this指针，不属于某一个对象而是属于类
//构造函数可不可以是虚函数：不可以是虚函数，虚函数的调用需要使用虚函数表指针，函数没构造的时候没有虚函数表指针。
//析构函数如果不是虚函数，作为基类会出现什么问题？   B：A    A* a = new B；这个a释放的时候(delete a) 只析构基类不析构派生类
//函数重载参数有const不构成重载(顶层指针，普通的const相当于顶层指针)，const成员函数可以和非const成员函数重载(本质上是因为const成员函数的this是底层const指针)。底层const也构成重载。
//基类和派生类只要有同名函数(不论参数和返回值)，没有被virtual修饰，那么基类的成员函数被隐藏。被virtual修饰就得满足虚函数的要求，参数数量要一致。
//reinterpret_cast  重新解释指针的意义为整型，或解释整型为指针，const_cast 只能用于去除指针或引用的常量性，底层指针的常量性
//static_cast的转换就是最普通的转换 在从大类型转到小类型时，先截断，在解释。如果位数一致，直接解释（如果两个位数一致但值范围不一致，unsigned 会根据位重新解释）。
//没有用到this指针的成员函数，是可以用一个nullptr对象来调用的。
//红黑树时间复杂度，插入全部数据的时间复杂度是nlogn，插入删除查找的时间复杂度是logn,哈希表的插入删除查找一般认为是1  
//三次握手如果丢包了tcp栈会怎么样？具体是要看实现，可能会有不同。 第一个包如果丢包了，相当于这个过程没有开始，client应该重发。第二个包如果丢了，server一定时间后应该重发，client也会重发，如果server收到了client的重发包，它会回复一个没有sync的ack，然后导致client发送一个rst，连接断开。或者server发送指定次数的第二个包始终守不到第三个包，那么也会断开连接。 第三个包丢了，client认为连接已经建立，会正常发送数据，这个时候如果server收到了，会回复一个rst，断开这个连接，也有可能不发，直接正常。第二个包和第三个包丢失的情况可以被用来泛洪攻击
//字节对齐问题：字节问题是和系统有关系的，是否和其他东西有关未知，但是一般的情况是：64位系统的指针8字节，32位系统指针4字节。如果没有使用#pragma pack，那么每个成员的起始地址必须和它自身的大小对齐，最后struct的大小要和它内部最大的元素的大小对齐。如果设置了#pragma pack，那么取该成员大小和#pragma pack的最小值作为对齐大小。
//vector清空的方法，清空 vector<int> a  vector<int>().swap(a);   将a与一个新建的vector交换，只是将大小和首尾指针进行交换，原来的数据变成临时值，会被析构掉。另一种用法： vector<int>(a).swap(a);可以将a变成最适合的大小。
//1.一个可执行文件 由代码段（text）、只读数据段.rodata（const全局变量）、已初始化的读写数据段data（static，全局变量），未初始化数据区bss(只存储大小和符号等信息，并不事实分配空间)。